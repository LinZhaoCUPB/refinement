function operators = operators_radialGrid(G, rock, operators)
% Modify operators for radialGrid in refined region
%
% PARAMETERS:
% G         - grid structure contains the radial grids
% rock      - rock properties
% operators - operators generated by setupOperatorsTPFA
%
% RETURNS:
% operators - some fields are modified based on the radial formulae,
%             including: operators.T_all
%                        operators.T
%                        operators.pv
%
% Written by Lin Zhao, CUPB, CHINA
%
% SEE ALSO:
%   `setupOperatorsTPFA`, `radialGrid`
%

T = computeTrans(G, rock);
[T, pv] = compute_radialGrid_trans(G, rock, T, operators.pv);
cf = G.cells.faces(:,1);
nf = G.faces.num;
T  = 1 ./ accumarray(cf, 1./T, [nf, 1]);

N = G.faces.neighbors;
intInx = all(N ~= 0, 2);
operators.T_all = T;
operators.T     = T(intInx);
operators.pv    = pv;
end

function [T, pv] = compute_radialGrid_trans(G, rock, T, pv)
% compute radial and angular face-transmissibility, Pedrosa and Aziz (1986)
% 1 - angular- direction
% 2 - angular+ direction
% 3 - radial-  direction
% 4 - radial+  direction

get_angle = @(x,y)acos(dot(x,y)/norm(x,2)/norm(y,2));

for i = 1:numel(G.refine)
    rc = G.refine(i).radial_cells;
    center = G.refine(i).center;
    for k = 1:length(rc)
        c = rc(k);
        perm = rock.perm(c,1); % only support isotropous ...
        faces = faces_of_cell(G, c);
        
        assert(length(faces)==4);
        
        coords1 = coords_of_face(G, faces(1));
        coords2 = coords_of_face(G, faces(2));
        
        al = get_angle(diff(coords1), diff(coords2));
        
        % face nodes radius, angular- direction
        fr1 = bsxfun(@minus, coords1, center);
        fr1 = sqrt( sum(fr1.^2,2) );
        
        % face nodes radius, angular+ direction
        fr2 = bsxfun(@minus, coords2, center);
        fr2 = sqrt( sum(fr2.^2,2) );
        
        % angular- face length == angular+ face length
        t = zeros(4,1);
        % angular face trans, angular-
        t(1) = perm*log( fr1(2)/fr1(1) ) / (al/2);
        % angular face trans, angular+
        t(2) = perm*log( fr2(2)/fr2(1) ) / (al/2);
        
        % cell radius
        cr0 = fr1(1);
        cr2 = fr1(2);
        
        % cell center radius
        alpha = cr2/cr0;
        cr1    = cr0 * exp( alpha^2/(alpha^2-1) * log(alpha) - 0.5 );
        
        t(3) = perm*al/log(cr1/cr0);
        
        t(4) = perm*al/log(cr2/cr1);
        
        facePos = G.cells.facePos(c) : G.cells.facePos(c+1)-1;
        
        T(facePos) = t;
        
        pv(c) = rock.poro(c) * ( al/2 * (cr2^2 - cr0^2) );
        
    end
end
end

function faces = faces_of_cell(G, c)
% faces of cell
ixc   = G.cells.facePos;
faces = G.cells.faces(ixc(c) : ixc(c + 1) - 1, 1);
end


function coords = coords_of_face(G, f)
% coordinates of face
ixf    = G.faces.nodePos;
nodes  = G.faces.nodes(ixf(f) : ixf(f + 1) - 1, 1);
coords = G.nodes.coords(nodes,:);
end

